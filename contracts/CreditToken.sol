// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.4;

import "hardhat/console.sol";

import {EIP20Interface} from "./dependencies/EIP20Interface.sol";
import {CreditTokenERC20} from "./CreditTokenERC20.sol";
import {CounterInterface} from "./Interfaces/CounterInterface.sol";
import {CRTInterface} from "./Interfaces/CRTInterface.sol";


contract CreditToken is
    CRTInterface,
    CreditTokenERC20("CREDIT_TOKEN", "CREDIT_TOKEN", 0) 
    {

    CounterInterface internal _counter;

    // 为了permit函数所设置的
    bytes32 public DOMAIN_SEPARATOR;

    bytes public constant EIP712_REVISION = bytes("1");

    bytes32 internal constant EIP712_DOMAIN =
        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    
    bytes32 public constant PERMIT_TYPEHASH =
        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

    /**
    * @notice Initializes the Credit Token
     */
    function initialize(
        CounterInterface counter,
        uint8 crtDecimals,
        string calldata crtName,
        string calldata crtSymbol,
        bytes calldata params
    ) external override {
        _setName(crtName);
        _setSymbol(crtSymbol);
        _setDecimals(crtDecimals);

        _counter = counter;

        // 获取链id，用来区分不同 EVM 链的一个标识
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                EIP712_DOMAIN,
                keccak256(bytes(crtName)),
                keccak256(EIP712_REVISION),
                chainId,
                address(this)
            )
        );
    }

    /**
     * @dev Calculates the balance of the user: principal balance + interest generated by the principal
     * @param user The user whose balance is calculated
     * @return The balance of the user
     */
    function balanceOf(address user)
        public
        view
        override(CreditTokenERC20, EIP20Interface)
        returns (uint256)
    {
        // return super.balanceOf(user).rayMul(_counter.getReserveNormalizedIncome(_underlyingAsset));
        // TODO: hardcode here for the first test;
        return super.balanceOf(user);
    }
}